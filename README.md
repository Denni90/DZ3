

Теперь само ДЗ, я старался и придумывал


* ## 1 уровень - обязательный:

    Дополнить файл с инструкцией по работе с Git и направить pull request в  мой репозиторий, Файл с инструкцией необходимо дополнить информацией о работе с удаленными репозиториями. В системе подгрузить скриншот отправленного pull request.

# Работа с удаленным репозиторием

## Что такое удаленный репозиторий?

Удаленный репозиторий – это версии проекта, сохраненные на удаленном сервере. Доступ к репозиторию на таком сервере может осуществляться по интернету или по локальной сети.
Удаленный репозиторий – полноценный репозиторий, ничем не отличающийся от локального. У удаленного репозитория есть собственные ветки, собственный указатель HEAD, своя история коммитов и так далее.
Если мы подключим удаленный репозиторий к своему локальному, то у нас появятся копии всех ссылочных объектов удаленного репозитория. То есть, например, у удаленного репозитория есть ветка main, а у нас будет копия этой ветки – origin/main. Все такие ссылочные объекты (указатели, ветки и теги) удаленного репозитория хранятся почти там же, где и у локального – в директории .git/refs/remotes/<имя_удаленного_репозитория>.

## Добавление удаленного репозитория к существующему локальному.

Со ссылкой на удаленный репозиторий тоже все просто. Мы работаем с GitHub, поэтому эту ссылку можно взять, нажав на большую зеленую кнопку Code на странице репозитория на GitHub.
Будет предложено выбрать одну из трех ссылок: для протоколов https и ssh и для клиента GitHub на компьютер. 

    Вот примеры этих трех ссылок для репозитория geometric_lib известного вам по практическим занятиям этого курса:
    HTTPS-ссылка: https://github.com/Denni90/DZ3.git
    SSH-ссылка: git@github.com:Denni90/DZ3.git
    GitHub CLI ссылка: gh repo clone Denni90/DZ3

Теперь разберемся, в чем отличие. Начнем с последней - эта ссылка используется в клиенте GitHub, который нужен для упрощения работы с Git. Этот клиент можно поставить отдельно, но его возможности значительно ограничены по сравнению с консольным вариантом Git.

* В чем разница между первыми двумя?

Дело в том, что существует два основных протокола подключения к git-серверу: HTTPS и SSH. SSH считается более надежным, но он немного сложнее в настройке. Давайте разберемся, как настроить подключение для каждого из них. А окончательный выбор протокола оставим на вкус читателя.

## Клонирование удаленного репозитория. 

Необходимость клонировать существующий удаленный репозиторий возникает в ситуациях, когда вы решаете поработать над уже существующим кодом. Для выполнения этой операции в Git предусмотрена команда **git clone**.

В директории, откуда вы запустили команду **git clone**, создается директория с именем репозитория. В нашем случае, если мы выполнили команду из директории пользователя, будет создана папка C:\My_DZ\DZ3\.
В созданную директорию копируется репозиторий, все его ветки и коммиты.
В новосозданный локальный репозиторий добавляется удаленный репозиторий с именем origin и ссылкой, которую мы передавали в **git clone**. Это избавляет нас от необходимости вручную писать ***git remote add origin https://github.com/Denni90/DZ3.git***. На этом процесс клонирования заканчивается.

## Получение изменений из удаленного репозитория

Итак, чтобы получить изменения из удаленного репозитория, в Git предусмотрена команда **git fetch**.

Давайте рассмотрим пример, чтобы разобраться, что на самом деле делает git fetch. Допустим, у нас есть репозиторий, к которому подключен удаленный репозиторий. Структура рабочих копий и логи выглядят следующим образом:

**Локальный репозиторий**
    ├── alpha.txt
    └── num.txt
    * 47573c7 | 2021-05-10 | Initial commit | [Smartiqa] |  (HEAD -> dev, origin/develop)

**Удаленный репозиторий**

    ├── alpha.txt
    ├── new_file.txt
    └── num.txt
    * b9ad22e | 2021-05-10 | New commit | [Smartiqa] |  (HEAD -> develop, origin/develop)
    * 47573c7 | 2021-05-10 | Initial commit | [Smartiqa] |

Как видно, в удаленном репозитории есть один коммит, которого нет у нас. В этом коммите был добавлен файл new_file.txt. Кроме того видно, что наша копия удаленной ветки origin/dev находится на первом коммите, хотя должна быть на втором. Чтобы обновить информацию для этой ветки, нам и понадобится git fetch. Выполним команду **git fetch origin**:

    Git Bash
    $ git fetch origin
    remote: Enumerating objects: 4, done.
    remote: Counting objects: 100% (4/4), done.
    remote: Compressing objects: 100% (2/2), done.
    remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
    Unpacking objects: 100% (3/3), 287 bytes | 143.00 KiB/s, done.
    From github.com:smartiqaorg/test-repo
    47573c7..b9ad22e  develop -> origin/develop

В выводе команды видно, что она скачала несколько объектов, а из последней строчки мы узнаем, что ветка develop удаленного репозитория была записана в ветку origin/develop на нашем компьютере.

## Получение изменений из удаленного репозитория

Связкой **git fetch && git merge** мы получили изменения из удаленного репозитория и обновили свою рабочую копию. Часто вместо этого хочется получать изменения и сразу обновлять рабочую копию так, чтобы она соответствовала удаленному репозиторию. И для этого в Git существует отдельная команда. Называется она **git pull**. Получает изменения из переданного удаленного репозитория и обновляет рабочую копию в соответствии с удаленным репозиторием. 

## Отправка изменений в удаленный репозиторий

Мы знаем почти все про удаленный репозиторий. Осталось изучить, как загружать в него свои локальные изменения. Для этого в __Git__ существует команда **git push**.

По факту данная команда аналогична связке **git fetch + git merge**, но выполненной из удаленного репозитория (это просто аналогия, на самом деле так сделать не получится).

Команда загружает изменения в удаленный репозиторий. Если слияние изменений в удаленном репозитории нельзя сделать в режиме *fast-forward*, и при этом не был передан ключ *force*, выполнение закончится с ошибкой.

Более подробно разберем, как работает эта команда. Допустим, мы выполнили ***git push origin develop*** в нашем локальном репозитории. 

##### Возможны три варианта развития событий.

Если изменения с нашей ветки можно слить с удаленной веткой в режиме ***fast-forward***, то есть на удаленной ветке нет коммитов сделанных после наших, то все пройдет нормально.

Если на удаленной ветке есть коммиты, которые были сделаны позже наших, то есть слияние в режиме ***fast-forward*** выполнить невозможно, то команда завершится с ошибкой. Ведь в этом случае есть угроза перезаписи истории удаленного репозитория и удаления всех коммитов, созданных позже наших.

Но если вы вдруг передали флаг ***--force***, то все коммиты, которых нет в вашем локальном репозитории, будут удалены. То есть удаленный репозиторий станет точной копией вашего локального. Есть более щадящая версия этого флага – ***--force-with-lease***. Он будет делать в точности то же самое, но если вдруг нужно будет удалить коммит, созданный не вами, выполнение немедленно прекратится и вернется ошибка.

* ## 2 уровень - рекомендуемый:

    Дополнить pull request своей визитной карточкой гитхаба readme.md. Постарайтесь написать свои мечты и желания, которые хотите реализовать с помощью новой профессии)) чтоб путеводная звезда горела и помогала учиться.

### Моя ссылка на личный кабинет - https://github.com/Denni90/Denni90.git

* ## 3 уровень - (по желанию) hardcore. 

    Перед вами непростая и интересная задача. Попробуйте сделать блок-схему и если получится, то крепите к pull request.


Эта задача, по слухам, предлагается на собеседовании в Гугл! дерзайте, попробуйте свои силы!

![сама задача](task.png)

https://stepik.org/lesson/3369/step/11?unit=952

ниже будут приведены комментарии людей

![коммент1](kom1.png)

![коммент1](kom4.png)

![коммент1](kom3.png)

![коммент1](kom5.png)
![коммент1](kom2.png)


кстати несколько вариантов вставки картинок , кто - то давно интересовался

https://ask-dev.ru/info/12384/add-images-to-readmemd-on-github
